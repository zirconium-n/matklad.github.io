
<!DOCTYPE html>
<html lang='en-US'>
<head>
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Value Oriented Programming Needs Implicits?</title>
  <meta name="description" content="An amateur note on language design which explores two important questions:">
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <link rel="canonical" href="https://matklad.github.io/2023/05/02/implicits-for-mvs.html">
  <link rel="alternate" type="application/rss+xml" title="matklad" href="https://matklad.github.io/feed.xml">
  <style>
  @font-face {
    font-family: 'Open Sans'; src: url('/css/OpenSans-300-Normal.woff2') format('woff2');
    font-weight: 300; font-style: normal;
  }
  @font-face {
    font-family: 'JetBrains Mono'; src: url('/css/JetBrainsMono-400-Normal.woff2') format('woff2');
    font-weight: 400; font-style: normal;
  }
  @font-face {
    font-family: 'JetBrains Mono'; src: url('/css/JetBrainsMono-700-Normal.woff2') format('woff2');
    font-weight: 700; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-400-Normal.woff2') format('woff2');
    font-weight: 400; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-400-Italic.woff2') format('woff2');
    font-weight: 400; font-style: italic;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-700-Normal.woff2') format('woff2');
    font-weight: 700; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-700-Italic.woff2') format('woff2');
    font-weight: 700; font-style: italic;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; margin-block-start: 0; margin-block-end: 0; }

  body {
    max-width: 80ch;
    padding: 2ch;
    margin-left: auto;
    margin-right: auto;
  }

  header { margin-bottom: 2rem; }
  header > nav { display: flex; column-gap: 2ch; align-items: baseline; flex-wrap: wrap; }
  header a { font-style: normal; color: rgba(0, 0, 0, .8); text-decoration: none; }
  header a:hover { color: rgba(0, 0, 0, .8); text-decoration: underline; }
  header .title { font-size: 1.25em; flex-grow: 2; }

  footer { margin-top: 2rem; }
  footer > p { display: flex; column-gap: 2ch; justify-content: center; flex-wrap: wrap; }
  footer a { color: rgba(0, 0, 0, .8); text-decoration: none; white-space: nowrap; }
  footer i { vertical-align: middle; color: rgba(0, 0, 0, .8) }

  </style>

  <link rel="stylesheet" href="/css/main.css">
  
</head>

<body>
  <header>
    <nav>
      <a class="title" href="/">matklad</a>
      <a href="/about.html">About</a>
      <a href="/links.html">Links</a>
      <a href="/blogroll.html">Blogroll</a>
    </nav>
  </header>

  <main>
  <article >

<h1><span>Value Oriented Programming Needs Implicits?</span> <time class="meta" datetime="2023-05-02">May 2, 2023</time></h1>
<p><span>An amateur note on language design which explores two important questions:</span></p>
<ul>
<li>
<span>How to do polymorphism?</span>
</li>
<li>
<span>How to do anything at all?</span>
</li>
</ul>
<p><span>Let</span>&rsquo;<span>s start with the second question.</span>
<span>What is the basic stuff that everything else is made of?</span></p>
<p><span>Not so long ago, the most popular answer to that question was </span>&ldquo;<span>objects</span>&rdquo;<span> </span>&mdash;<span> blobs of mutable state with references to other blobs.</span>
<span>This turned out to be problematic </span>&mdash;<span> local mutation of an object might accidentally cause unwanted changes elsewhere.</span>
<span>Defensive copying of collections at the API boundary was a common pattern.</span></p>
<p><span>Another answer to the question of basic stuff  is </span>&ldquo;<span>immutable values</span>&rdquo;<span>, as exemplified by functional programming.</span>
<span>This fixes the ability to reason about programs locally at the cost of developer ergonomics and expressiveness.</span>
<span>A lot of code is naturally formulated in terms of </span>&ldquo;<span>let</span>&rsquo;<span>s mutate this little thing</span>&rdquo;<span>, and functionally threading the update through all the layers is tiresome.</span></p>
<p><span>The C answer is that everything is made of </span>&ldquo;<span>memory (*)</span>&rdquo;<span>.</span>
<span>It is almost as if memory is an array of bytes.</span>
<span>Almost, but not quite </span>&mdash;<span> to write portable programs amenable to optimization, certain restrictions must be placed on the ways memory is accessed and manipulated, hence (*).</span>
<span>These restrictions not being checked by the compiler (and not even visible in the source code) create a fertile ground for subtle bugs.</span></p>
<p><span>Rust takes this basic C model and:</span></p>
<ul>
<li>
<span>Makes the (*) explicit:</span>
<ul>
<li>
<span>pointers always carry the size of addressed memory, possibly at runtime (slices),</span>
</li>
<li>
<span>pointers carry lifetime, accessing the data past the end of the lifetime is forbidden.</span>
</li>
</ul>
</li>
<li>
<span>Adds aliasing information to the type system, such that it becomes possible to tell if there are </span><em><span>other</span></em><span> pointers pointing at a particular piece of memory.</span>
</li>
</ul>
<p><span>Curiously, this approach allows rust to have an </span>&ldquo;<span>immutable values</span>&rdquo;<span> feel, without requiring the user to thread updates manually,</span>
<a href="http://smallcultfollowing.com/babysteps/blog/2018/02/01/in-rust-ordinary-vectors-are-values/">&ldquo;<span>In Rust, Ordinary Vectors are Values</span>&rdquo;</a><span>.</span>
<span>But the cognitive cost for this approach is pretty high, as the universe of values is now forked by different flavors of owning/referencing.</span></p>
<p><span>Let</span>&rsquo;<span>s go back to the pure FP model.</span>
<span>Can we just locally fix it?</span>
<span>Let</span>&rsquo;<span>s take a look at an example:</span></p>

<figure class="code-block">


<pre><code><span class="line">let xs1 = get_items() in</span>
<span class="line">let xs2  = modify_items(xs1) in</span>
<span class="line">let xs3 = sort_items(xs2) in</span>
<span class="line">...</span></code></pre>

</figure>
<p><span>It is pretty clear that we can allow mutation of local variables via a simple rewrite, as that won</span>&rsquo;<span>t compromise local reasoning:</span></p>

<figure class="code-block">


<pre><code><span class="line">var xs = get_items()</span>
<span class="line">xs = modify_items(xs)</span>
<span class="line">xs = sort_items(xs)</span></code></pre>

</figure>
<p><span>Similarly, we can introduce a rewrite rule for the ubiquitous </span><code>x = f(x)</code><span> pattern, such that the code looks like this:</span></p>

<figure class="code-block">


<pre><code><span class="line">var xs = get_items()</span>
<span class="line">modify_items(xs)</span>
<span class="line">sort_items(xs)</span></code></pre>

</figure>
<p><span>Does this actually work?</span>
<span>Yes, it does, as popularized by Swift and distilled in its pure form by </span><a href="https://www.val-lang.dev"><span>Val</span></a><span>.</span></p>
<p><span>Formalizing the rewriting reasoning, we introduce second-class references, which can </span><em><span>only</span></em><span> appear in function arguments (</span><code>inout</code><span> parameters), but, eg, can</span>&rsquo;<span>t be stored as fields.</span>
<span>With these restrictions, </span>&ldquo;<span>borrow checking</span>&rdquo;<span> becomes fairly simple </span>&mdash;<span> at each function call it suffices to check that no two </span><code>inout</code><span> arguments overlap.</span></p>
<p><span>Now, let</span>&rsquo;<span>s switch gears and explore the second question </span>&mdash;<span> polymorphism.</span></p>
<p><span>Starting again with OOP, you can use subtyping with its familiar </span><span class="display"><code>class Dog extends Triangle</code><span>,</span></span><span> but that is not very flexible.</span>
<span>In particular, expressing something like </span>&ldquo;<span>sorting a list of items</span>&rdquo;<span> with pure subtyping is not too natural.</span>
<span>What works better is parametric polymorphism, where you add type parameters to your data structures:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">sort</span>&lt;T&gt;(items: &amp;<span class="hl-keyword">mut</span> <span class="hl-type">Vec</span>&lt;T&gt;)</span></code></pre>

</figure>
<p><span>Except that it doesn</span>&rsquo;<span>t quite work as, as we also need to specify how to sort the </span><code>T</code><span>s.</span>
<span>One approach here would be to introduce some sort of type-of-types, to group types with similar traits into a class:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">sort</span>&lt;T: Comparable&gt;(items: &amp;<span class="hl-keyword">mut</span> <span class="hl-type">Vec</span>&lt;T&gt;)</span></code></pre>

</figure>
<p><span>A somewhat simpler approach is to just explicitly pass in a comparison function:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">sort</span>&lt;T&gt;(</span>
<span class="line">    compare: <span class="hl-title function_ invoke__">fn</span>(T, T) <span class="hl-punctuation">-&gt;</span> <span class="hl-type">bool</span>,</span>
<span class="line">    items: &amp;<span class="hl-keyword">mut</span> <span class="hl-type">Vec</span>&lt;T&gt;,</span>
<span class="line">)</span></code></pre>

</figure>
<p><span>How does this relate to value oriented programming?</span>
<span>It happens that, when programming with values, a very common pattern is to use indexes to express relationships.</span>
<span>For example, to model parent-child relations (or arbitrary graphs), the following setup works:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">type</span> <span class="hl-title class_">Tree</span> = <span class="hl-type">Vec</span>&lt;Node&gt;;</span>
<span class="line"><span class="hl-keyword">struct</span> <span class="hl-title class_">Node</span> {</span>
<span class="line">    parent: <span class="hl-type">usize</span>,</span>
<span class="line">    children: <span class="hl-type">Vec</span>&lt;<span class="hl-type">usize</span>&gt;,</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>Using direct references hits language limitations:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">struct</span> <span class="hl-title class_">Node</span> {</span>
<span class="line">    parent: Node, <span class="hl-comment">// Who owns that?</span></span>
<span class="line">    children: <span class="hl-type">Vec</span>&lt;Node&gt;,</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>Another good use-case is interning, where you have something like this:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">struct</span> <span class="hl-title class_">NameTable</span> {</span>
<span class="line">    strings: <span class="hl-type">Vec</span>&lt;<span class="hl-type">String</span>&gt;,</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">struct</span> <span class="hl-title class_">Name</span>(<span class="hl-type">u32</span>);</span></code></pre>

</figure>
<p><span>How do we sort a </span><code>Vec&lt;Name&gt;</code><span>?</span>
<span>We can</span>&rsquo;<span>t use the type class approach here, as knowing the </span><em><span>type</span></em><span> of </span><code>Name</code><span> isn</span>&rsquo;<span>t enough to sort names lexicographically, an instance of </span><code>NameTable</code><span> is also required to fetch the actual string data.</span>
<span>The approach with just passing in comparison function works, as it can close over the correct </span><code>NameTable</code><span> in scope.</span></p>
<p><span>The problem with </span>&ldquo;<span>just pass a function</span>&rdquo;<span> is that it gets tedious quickly.</span>
<span>Rather than </span><span class="display"><code>xs.print()</code></span><span> you now need to say </span><span class="display"><code>xs.print(Int::print)</code><span>.</span></span>
<span>Luckily, similarly to how the compiler infers the type parameter </span><code>T</code><span> by default, we can allow limited inference of value parameters, which should remove most of the boilerplate.</span>
<span>So, something which looks like </span><span class="display"><code>names.print()</code></span><span> would desugar to </span><span class="display"><code>Vec::print_vec(self.name_table.print, names)</code><span>.</span></span></p>
<p><span>This could also synergize well with compile-time evaluation.</span>
<span>If (as is the common case), the value of the implicit function table is known at compile time, no table needs to be passed in at runtime (and we don</span>&rsquo;<span>t have to repeatedly evaluate the table itself).</span>
<span>We can even compile-time partially evaluate things within the compilation unit, and use runtime parameters at the module boundaries, just like Swift does.</span></p>
<p><span>And that</span>&rsquo;<span>s basically it!</span>
<span>TL;DR: value oriented programming / mutable value semantics is an interesting </span>&ldquo;<span>everything is X</span>&rdquo;<span> approach to get the benefits of functional purity without giving up on mutable hash tables.</span>
<span>This style of programming doesn</span>&rsquo;<span>t work with cyclic data structures (values are always trees), so indexes are often used to express auxiliary relations.</span>
<span>This, however, gets in a way of type-based generic programming </span>&mdash;<span> a </span><code>T</code><span> is no longer </span><code>Comparable</code><span>, only </span><code>T + Context</code><span> is.</span>
<span>A potential fix for that is to base generic programming on explicit dictionary passing combined with implicit value parameter inference.</span></p>
<p><span>Is there a language like this already?</span></p>
<p><span>Links:</span></p>
<ul>
<li>
<a href="https://www.val-lang.dev"><span>Val</span></a>
</li>
<li>
<a href="https://arxiv.org/pdf/1512.01895.pdf"><span>Modular implicits</span></a>
</li>
<li>
<a href="https://rust-lang.github.io/async-fundamentals-initiative/evaluation/design/with_clauses.html"><span>With clauses</span></a>
</li>
<li>
<a href="https://www.youtube.com/watch?v=ctS8FzqcRug"><span>Implementing Swift generics</span></a>
</li>
</ul>
</article>
  </main>

  <footer>
    <p>
      <a href="https://github.com/matklad/matklad.github.io/edit/master/content/posts/2023-05-02-implicits-for-mvs.dj">
        <svg class="icon"><use href="/assets/icons.svg#edit"/></svg>
        Fix typo
      </a>
      <a href="/feed.xml">
        <svg class="icon"><use href="/assets/icons.svg#rss"/></svg>
        Subscribe
      </a>
      <a href="mailto:aleksey.kladov+blog@gmail.com">
        <svg class="icon"><use href="/assets/icons.svg#email"/></svg>
        Get in touch
      </a>
      <a href="https://github.com/matklad">
        <svg class="icon"><use href="/assets/icons.svg#github"/></svg>
        matklad
      </a>
    </p>
  </footer>
</body>

</html>
